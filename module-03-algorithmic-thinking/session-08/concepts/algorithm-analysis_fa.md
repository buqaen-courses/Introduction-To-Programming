# تحلیل الگوریتم: سنجش کارایی به زبان ساده

## خوش آمدید، مبتدی!

قبل از شروع، این موارد را باید بدانید:
- مفاهیم اولیه برنامه‌نویسی (حلقه‌ها، توابع)
- ریاضی ساده (جمع، ضرب)
- کنجکاوی درباره اینکه چرا بعضی برنامه‌ها سریع‌تر از بقیه اجرا می‌شوند!

---

## ۱. داستان "چرا باید اهمیت بدهم؟"

### سناریو کتابخانه

فرض کنید باید یک کتاب در دو کتابخانه مختلف پیدا کنید:

**کتابخانه A (شهر کوچک):** ۱۰۰ کتاب، به صورت تصادفی توده شده
- شما هر کتاب را یکی یکی بررسی می‌کنید
- بدترین حالت: ۱۰۰ بررسی
- زمان: ۱۰ دقیقه

**کتابخانه B (شهر بزرگ):** ۱٫۰۰۰٫۰۰۰ کتاب، کاملاً سازمان‌یافته با سیستم فهرست
- جستجوی فهرست → رفتن به قفسه دقیق → پیدا کردن کتاب
- حداکثر بررسی: ~۲۰
- زمان: ۲ دقیقه

**حقیقت شگفت‌انگیز:** کتابخانه B ۵ برابر سریع‌تر است، علی‌رغم اینکه ۱۰٬۰۰۰ برابر کتاب بیشتر دارد!

این دقیقاً همان چیزی است که تحلیل الگوریتم به ما می‌آموزد: **داده بزرگ‌تر همیشه به معنای برنامه کندتر نیست** اگر از الگوریتم درست استفاده کنید.

---

## ۲. واقعاً چه چیزی را اندازه می‌گیریم؟

### دو منبعی که اهمیت دارند

```
┌─────────────────────────────────────────────────────────┐
│  تحلیل الگوریتم = سنجش دو چیز                           │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ۱. پیچیدگی زمانی: "با رشد داده، چقدر طولانی‌تر؟"        │
│     → مثل سنجش نحوه مقیاس‌پذیری یک دستور غذا برای مهمان‌های بیشتر │
│                                                          │
│  ۲. پیچیدگی فضایی: "چقدر حافظه اضافی لازم است؟"          │
│     → مثل سنجش چند کاسه اضافی نیاز دارید                 │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### چرا فقط ثانیه نمی‌شماریم؟

| کامپیوتر | کامپیوتر سریع | کامپیوتر کند |
|----------|---------------|---------------|
| الگوریتم A | ۰٫۰۰۱ ثانیه | ۰٫۱ ثانیه |
| الگوریتم B | ۱۰ ثانیه | ۱۰۰۰ ثانیه |

**عملکرد نسبی** صرف نظر از کامپیوتر یکسان می‌ماند!

> **نکته کلیدی:** ما اندازه‌گیری می‌کنیم که یک الگوریتم *چگونه مقیاس می‌یابد*، نه اینکه یک کامپیوتر خاص چقدر سریع آن را اجرا می‌کند.

---

## ۳. نماد Big O: زبان رشد

### Big O چیست؟

Big O به ما می‌گوید حجم کار یک الگوریتم با رشد اندازه ورودی چقدر افزایش می‌یابد.

مثل مقایسه الگوهای رشد فکر کنید:

| الگوی رشد | تشبیه دنیای واقعی |
|----------------|-------------------|
| ثابت O(1) | روشن کردن کلید (همان تلاش، هر اندازه اتاق) |
| لگاریتمی O(log n) | یافتن کلمه در دیکشنری (دیکشنری بزرگ‌تر، تلاش اندکی بیشتر) |
| خطی O(n) | شمردن افراد در یک صف (افراد بیشتر = زمان بیشتر) |
| درجه دوم O(n²) | دست دادن در یک گروه (همه با همه دست می‌دهند) |

### نمودار "سرعت" Big O برای مبتدی‌ها

```
سرعت (سریع‌ترین به کندترین)
│
│    ⚡ فوری            O(1)          ───────────────
│       │                              
│    🚀 خیلی سریع        O(log n)      ─────╲
│       │                                    ╲
│    🚶 پایدار           O(n)          ───────╲
│       │                                       ╲
│    🐢 کند             O(n log n)    ───────╲__╲
│       │                                         ╲
│    🐌 خیلی کند        O(n²)         ───────────╲___╲
│       │                                              ╲
│    🚫 اجتناب          O(2ⁿ)         ───────────────╲___╲
│       │                                                    ╲
└───────────────────────────────────────────────────────────────
     ۱۰     ۱۰۰     ۱٬۰۰۰     ۱۰٬۰۰۰    ۱۰۰٬۰۰۰   n (اندازه ورودی)
```

---

## ۴. درک هر پیچیدگی (با داستان‌ها!)

### O(1) - زمان ثابت: "دستگاه فروش

**داستان:** یک دستگاه فروش دکمه‌های ۱ تا ۱۰ دارد. چه دکمه ۱ را فشار دهید چه ۱۰، زمان یکسانی طول می‌کشد تا میان‌وعده خود را بگیرید.

**معنی:** عملیات صرف نظر از میزان داده، زمان یکسانی می‌برد.

```python
# مثال‌های عملیات O(1)
def get_first_item(items):
    return items[0]  # دسترسی مستقیم - فوری!

def check_if_empty(items):
    return len(items) == 0  # یک بررسی - فوری!

def calculate_circle_area(radius):
    return 3.14159 * radius * radius  # عملیات ریاضی - فوری!
```

**وقتی O(1) می‌بینید:** به "دسترسی مستقیم" یا "عملیات واحد" فکر کنید

---

### O(log n) - زمان لگاریتمی: "روش دفتر تلفن"

**داستان:** یافتن "Smith" در دفتر تلفن:
1. باز کردن وسط (بخش M)
2. "S" بعد از "M" می‌آید، بنابراین نیمه اول را نادیده بگیرید
3. باز کردن وسط صفحات باقی‌مانده (بخش S-T)
4. ادامه نصف کردن تا پیدا کنید

**معنی:** دو برابر کردن داده، تقریباً هیچ کار اضافی اضافه نمی‌کند!

```python
def find_in_phone_book(names, target):
    """
    جستجوی دودویی - روش دفتر تلفن
    
    ۱۰ اسم   → ~۳ بررسی
    ۱۰۰ اسم  → ~۷ بررسی  
    ۱۰۰۰ اسم → ~۱۰ بررسی
    ۱ میلیون  → ~۲۰ بررسی
    """
    left = 0
    right = len(names) - 1
    
    while left <= right:
        middle = (left + right) // 2
        
        if names[middle] == target:
            return middle  # پیدا شد!
        elif names[middle] < target:
            left = middle + 1  # هدف در نیمه راست است
        else:
            right = middle - 1  # هدف در نیمه چپ است
    
    return -1  # پیدا نشد
```

**بصری:**
```
جستجو: [A, B, C, D, E, F, G, H] برای "G"

گام ۱: بررسی وسط (D)        [A B C D | E F G H]
        "G" > "D"، برو راست
        
گام ۲: بررسی وسط راست   [E F | G H]
        "G" > "F"، برو راست
        
گام ۳: بررسی وسط            [G | H]
        پیدا شد!
        
فقط ۳ بررسی برای ۸ آیتم!
```

---

### O(n) - زمان خطی: "خط تولید"

**داستان:** بررسی بلیط در یک کنسرت. ۱۰۰ نفر = ۱۰۰ بررسی. ۱۰۰۰ نفر = ۱۰۰۰ بررسی. هر نفر یک واحد کار اضافه می‌کند.

**معنی:** کار با همان نرخ داده رشد می‌کند.

```python
def find_max_score(scores):
    """
    یافتن بالاترین نمره در لیست.
    باید هر نمره را یک بار بررسی کند.
    """
    max_score = scores[0]  # شروع با اولی
    
    for score in scores:   # بررسی هر کدام
        if score > max_score:
            max_score = score
    
    return max_score

# ۱۰ نمره  → ~۱۰ مقایسه
# ۱۰۰ نمره → ~۱۰۰ مقایسه
```

**وقتی O(n) می‌بینید:** به "یک حلقه روی داده" فکر کنید

---

### O(n²) - زمان درجه دوم: "مشکل دست دادن"

**داستان:** در یک مهمانی ۱۰ نفره، همه با همه دست می‌دهند. چند دست دادن؟
- نفر ۱ با ۹ نفر دیگر دست می‌دهد
- نفر ۲ با ۸ نفر باقی‌مانده دست می‌دهد
- ... و الی آخر
- مجموع: ~۴۵ دست دادن

در مهمانی ۱۰۰ نفره؟ ~۴۹۵۰ دست دادن!

**معنی:** اگر داده دو برابر شود، کار چهار برابر می‌شود!

```python
def find_duplicate_names(names):
    """
    بررسی اینکه آیا دو نفر نام یکسان دارند.
    بررسی هر جفت نام.
    """
    duplicates = []
    
    for i in range(len(names)):           # حلقه بیرونی: n بار
        for j in range(i + 1, len(names)): # حلقه درونی: n بار
            if names[i] == names[j]:
                duplicates.append(names[i])
    
    return duplicates

# ۱۰ اسم  → ~۴۵ مقایسه
# ۱۰۰ اسم → ~۴۹۵۰ مقایسه  (۱۰ برابر داده، ۱۰۰ برابر کار!)
```

**بصری:**
```
بررسی موارد تکراری در [A, B, C, D]:

A ↔ B  A ↔ C  A ↔ D
       B ↔ C  B ↔ D
              C ↔ D

۴ آیتم → ۶ مقایسه
هر آیتم جدید با همه قبلی‌ها مقایسه می‌شود!
```

**چراغ قرمز:** حلقه‌های تودرتو معمولاً O(n²) یا بدتر یعنی!

---

## ۵. چگونه پیچیدگی زمانی را محاسبه کنیم (گام‌به‌گام)

### روش "شمارش کار"

نگران دقیق بودن نباشید. فقط عملیات غالب را شناسایی کنید.

#### مثال ۱: حلقه ساده

```python
def count_students_passing(scores, passing_score=60):
    count = 0                      # ۱ عملیات (نادیده - ثابت)
    for score in scores:           # n تکرار
        if score >= passing_score: # ۱ عملیات
            count += 1             # ۱ عملیات
    return count                   # ۱ عملیات (نادیده - ثابت)

# کار کل: n × (۱ + ۱) = 2n
# ساده شده: O(n)
```

**تحلیل گام‌به‌گام:**
1. حلقه را پیدا کنید: `for score in scores`
2. چند تکرار؟ `n` (یکی برای هر نمره)
3. داخل چه اتفاقی می‌افتد؟ ۲ عملیات
4. مجموع: O(n) - ثابت ۲ اهمیتی ندارد!

#### مثال ۲: حلقه‌های تودرتو

```python
def print_all_pairs(students):
    for student1 in students:        # n تکرار
        for student2 in students:    # n تکرار
            print(student1, student2)  # ۱ عملیات

# کار کل: n × n × ۱ = n²
# پیچیدگی: O(n²)
```

**تحلیل گام‌به‌گام:**
1. حلقه بیرونی را پیدا کنید: `n` بار اجرا می‌شود
2. حلقه درونی را پیدا کنید: برای هر تکرار بیرونی `n` بار اجرا می‌شود
3. ضرب کنید: n × n = n²
4. نتیجه: O(n²)

#### مثال ۳: حلقه‌های متوالی

```python
def process_twice(items):
    for item in items:      # n تکرار
        print(item)         # ۱ عملیات
    
    for item in items:      # n تکرار دوباره
        process(item)       # ۱ عملیات

# کار کل: n + n = 2n
# ساده شده: O(n)  (ثابت‌ها را حذف می‌کنیم!)
```

**مهم:** حلقه‌های متوالی جمع می‌شوند، ضرب نمی‌شوند!

---

## ۶. پیچیدگی فضایی: مصرف حافظه

### چه چیزی شمارش می‌شود؟

فقط حافظه **اضافی** که الگوریتم استفاده می‌کند را می‌شماریم، نه خود ورودی.

### O(1) فضا: "بدون ذخیره‌سازی اضافی"

```python
def find_max(numbers):
    max_val = numbers[0]    # یک متغیر اضافی
    
    for num in numbers:
        if num > max_val:
            max_val = num   # استفاده مجدد از همان متغیر
    
    return max_val

# فضا: O(1) - همیشه فقط یک متغیر اضافی استفاده می‌کند
```

**بصری:**
```
ورودی: [5, 2, 8, 1, 9]  ←── این را نمی‌شماریم
        ↓
اضافی: max_val = 9      ←── فقط این را می‌شماریم (۱ متغیر)
```

### O(n) فضا: "ایجاد کپی"

```python
def double_all(numbers):
    result = []              # لیست جدید در حال ایجاد
    for num in numbers:
        result.append(num * 2)  # با ورودی رشد می‌کند
    return result

# فضا: O(n) - لیست نتیجه n آیتم دارد
```

---

## ۷. جدول مقایسه دوستانه برای مبتدی‌ها

### الگوریتم‌های جستجو

| الگوریتم | بهترین برای | زمان | فضا | تشبیه ساده |
|-----------|----------|------|-------|----------------|
| جستجوی خطی | داده مرتب نشده | O(n) | O(1) | بررسی هر کشو |
| جستجوی دودویی | داده مرتب شده | O(log n) | O(1) | روش دفتر تلفن |
| جستجوی هش | جستجوهای مکرر | O(1) | O(n) | دفترچه آدرس مستقیم |

### الگوریتم‌های مرتب‌سازی

| الگوریتم | بهترین حالت | بدترین حالت | چه موقع استفاده کنیم |
|-----------|-----------|------------|-------------|
| مرتب‌سازی حبابی | O(n) | O(n²) | هرگز، فقط برای یادگیری |
| مرتب‌سازی سریع | O(n log n) | O(n²) | عمومی (سریع‌ترین میانگین) |
| مرتب‌سازی ادغامی | O(n log n) | O(n log n) | وقتی سرعت یکنواخت اهمیت دارد |

---

## ۸. اشتباهات رایج مبتدی‌ها (و چگونه از آنها اجتناب کنیم!)

### اشتباه ۱: "باید هر عملیات را بشمارم!"

**فکر اشتباه:**
```
این تابع 3n + 5 عملیات انجام می‌دهد، پس O(3n + 5) است
```

**فکر درست:**
```
ما فقط به اصطلاح غالب با رشد n اهمیت می‌دهیم.
O(3n + 5) → O(n)
```

**به خاطر بسپارید:** ثابت‌ها و اصطلاحات کم‌تر را حذف کنید!

### اشتباه ۲: "حلقه‌های تودرتو همیشه O(n²) یعنی!"

**همیشه درست نیست:**
```python
def find_pairs_with_target(numbers, target):
    # این O(n²) به نظر می‌رسد اما واقعاً O(n) است!
    seen = set()
    for num in numbers:           # n تکرار
        if target - num in seen:  # جستجوی O(1)
            return True
        seen.add(num)             # افزودن O(1)
    return False
```

**درس:** به آنچه داخل حلقه اتفاق می‌افتد نگاه کنید، نه فقط ساختار حلقه!

### اشتباه ۳: "Big O تنها چیزی که اهمیت دارد"

**این را در نظر بگیرید:**
- الگوریتم A: O(n) اما کد ساده
- الگوریتم B: O(log n) اما ۱۰۰۰ خط کد پیچیده

**برای داده کوچک (n < ۱۰۰):** الگوریتم A ممکن است سریع‌تر باشد!
**برای داده بزرگ (n > ۱٫۰۰۰٫۰۰۰):** الگوریتم B برنده می‌شود!

---

## ۹. زمان تمرین!

### تمرین ۱: شناسایی پیچیدگی

پیچیدگی زمانی هر تابع چیست؟

```python
# تابع ۱
def mystery_a(items):
    print(items[0])

# تابع ۲
def mystery_b(items):
    for i in items:
        for j in items:
            print(i, j)

# تابع ۳
def mystery_c(items):
    for i in range(5):
        print(i)

# تابع ۴
def mystery_d(items):
    while len(items) > 1:
        items = items[:len(items)//2]
```

**پاسخ‌ها:**
- تابع ۱: O(1) - فقط دسترسی به اولین آیتم
- تابع ۲: O(n²) - حلقه‌های تودرتو
- تابع ۳: O(1) - تعداد تکرار ثابت (۵)
- تابع ۴: O(log n) - نصف کردن مکرر

### تمرین ۲: بهینه‌سازی کنید!

```python
# فعلی: O(n²)
def has_duplicate(numbers):
    for i in range(len(numbers)):
        for j in range(len(numbers)):
            if i != j and numbers[i] == numbers[j]:
                return True
    return False

# آیا می‌توانید آن را O(n) کنید؟ راهنما: از set استفاده کنید!
def has_duplicate_fast(numbers):
    # راه‌حل شما اینجا
    pass
```

**راه‌حل:**
```python
def has_duplicate_fast(numbers):
    seen = set()
    for num in numbers:
        if num in seen:
            return True
        seen.add(num)
    return False
```

---

## ۱۰. مرجع سریع: راهنمای "در یک نگاه"

### چگونه هر الگوریتمی را تحلیل کنیم

```
گام ۱: حلقه‌ها را پیدا کنید
        ↓
گام ۲: تعداد تکرارها را بشمارید (بر حسب n)
        ↓
gam ۳: تودرتایی را جستجو کنید (ضرب!)
        ↓
گام ۴: فقط بزرگ‌ترین اصطلاح را نگه دارید
        ↓
گام ۵: ثابت را حذف کنید
        ↓
Big O شما آماده است!
```

### برگه تقلب پیچیدگی

| می‌بینید... | احتمالاً... | فکر کنید... |
|------------|------------------|----------|
| حلقه ساده روی داده | O(n) | "یک عبور" |
| حلقه داخل حلقه | O(n²) | "دست دادن‌ها" |
| نصف کردن مسئله | O(log n) | "دفتر تلفن" |
| بدون حلقه، دسترسی مستقیم | O(1) | "فوری" |
| مرتب‌سازی | O(n log n) | "مرتب‌سازی کارآمد" |

---

## ۱۱. نکات کلیدی برای مبتدی‌ها

1. **Big O رشد را توصیف می‌کند**: حجم کار چگونه با رشد داده افزایش می‌یابد؟

2. **ترتیب مهم‌تر از اعداد دقیق است**: O(n) همیشه برای داده بزرگ از O(n²) بهتر است

3. **ثابت‌ها در Big O اهمیت ندارند**: O(2n) و O(n) یکسان‌اند

4. **عملکرد واقعی متفاوت است**: Big O درباره مقیاس‌پذیری است، نه سرعت مطلق

5. **حلقه‌های تودرتو یک چراغ قرمز هستند**: اما بررسی کنید واقعاً چه می‌کنند!

---

## این را به خاطر بسپارید!

```
┌────────────────────────────────────────────────────────────┐
│  تحلیل الگوریتم در ۳ جمله                                 │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  ۱. "حجم کار با رشد داده چگونه افزایش می‌یابد؟"          │
│                                                             │
│  ۲. O(1) < O(log n) < O(n) < O(n log n) < O(n²)           │
│                                                             │
│  ۳. ثابت‌ها را حذف کنید، بزرگ‌ترین اصطلاح را نگه دارید    │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

### گام‌های بعدی

- تمرین تحلیل توابع ساده که می‌نویسید
- مقایسه رویکردهای مختلف برای یک مسئله
- یادگیری درباره ساختارهای داده و عملیات آنها
- بررسی وقتی O(n²) واقعاً خوب است (داده کوچک!)
