# ویژگی‌های الگوریتم: چارچوب FIDEO برای مبتدی‌ها

## چه چیزی چیزی را به الگوریتم تبدیل می‌کند؟

قبل از بررسی ویژگی‌ها، بیایید تفاوت بین هر مجموعه دستورالعمل و یک الگوریتم را درک کنیم.

### تست دستور غذا

**دستورالعمل معمولی (الگوریتم نیست):**
```
طرز تهیه سوپ مادربزرگ:
۱. مواد لازم را اضافه کنید
۲. تا جایی که خوب به نظر می‌رسد بپزید
۳. طبق مزه نمک بزنید
```

**نسخه الگوریتم:**
```
الگوریتم: تهیه سوپ مرغ
─────────────────────────────
ورودی: ۲ سینه مرغ، ۴ پیمانه آب، ۱ پیاز، نمک

۱. پیاز را به تکه‌های ۱ سانتی‌متری خرد کنید
۲. مرغ را به مکعب‌های ۲ سانتی‌متری برش دهید
۳. آب، مرغ و پیاز را در قابلمه بریزید
۴. به جوش بیاورید (۱۰۰°C)
۵. حرارت را کم کنید، ۳۰ دقیقه بپزید
۶. ۱ قاشق چایخوری نمک اضافه کنید
۷. فوراً سرو کنید

خروجی: ۴ پرس سوپ مرغ
```

**تفاوت چیست؟** نسخه دوم دقیق، دارای ورودی/خروجی مشخص، و هر کسی می‌تواند دقیقاً آن را دنبال کند!

---

## پنج ویژگی ضروری (FIDEO)

**FIDEO** را به خاطر بسپارید - چک لیست کیفیت الگوریتم شما:

```
┌─────────────────────────────────────────────────────────────┐
│                    چک لیست FIDEO                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  F - FINITE (پایان‌پذیری)    → آیا تمام می‌شود؟              │
│  I - INPUT (ورودی)           → چه داده‌ای نیاز دارد؟       │
│  D - DEFINITE (قطعیت)        → آیا هر گام کاملاً واضح است؟  │
│  E - EFFECTIVE (اثربخشی)     → آیا هر گام واقعاً قابل انجام است؟ │
│  O - OUTPUT (خروجی)          → چه نتیجه‌ای تولید می‌کند؟      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## ۱. پایان‌پذیری: باید تمام شود (در نهایت!)

### معنی آن

یک الگوریتم نمی‌تواند برای همیشه اجرا شود. باید پس از تعداد مشخص و پایانی از گام‌ها تکمیل شود.

### تشبیه دنیای واقعی: مسیر اتوبوس

**الگوریتم خوب (پایان‌پذیر):**
```
مسیر اتوبوس شهری:
۱. شروع در ایستگاه A
۲. رفتن به ایستگاه B
۳. رفتن به ایستگاه C
۴. رفتن به ایستگاه D
۵. بازگشت به ایستگاه A
۶. پایان
```
→ اتوبوس ۵ ایستگاه دارد. حتماً تمام می‌شود.

**الگوریتم بد (ناپایان):**
```
اتوبوس حلقه بی‌پایان:
۱. شروع در ایستگاه A
۲. رفتن به ایستگاه بعدی
۳. برگشت به گام ۲
```
→ اتوبوس هرگز متوقف نمی‌شود! مسافران برای همیشه محبوس می‌شوند.

### مثال‌های کد

**پایان‌پذیر (خوب):**
```python
def countdown(n):
    """شمارش معکوس از n تا ۰."""
    while n > 0:        # شرطی که FALSE می‌شود
        print(n)
        n = n - 1       # n هر بار کاهش می‌یابد
    print("Blast off!")
    # حتماً وقتی n به ۰ برسد تمام می‌شود

countdown(5)
# خروجی: ۵، ۴، ۳، ۲، ۱، Blast off!
```

**ناپایان (بد):**
```python
def broken_countup(n):
    """این هرگز متوقف نمی‌شود!"""
    while n > 0:
        print(n)
        n = n + 1       # n برای همیشه رشد می‌کند!
    # هرگز به این خط نمی‌رسد
```

**چرا n برای همیشه رشد می‌کند:**
- شروع: n = ۵
- پس از تکرار ۱: n = ۶
- پس از تکرار ۲: n = ۷
- شرط `n > 0` همیشه TRUE است!

### اشتباه رایج مبتدی‌ها

```python
def find_number(numbers, target):
    i = 0
    while numbers[i] != target:  # خطرناک!
        i = i + 1
    return i

# مشکل: اگر target در لیست نباشد چه؟
# حلقه برای همیشه اجرا می‌شود (یا crash می‌کند)!

# نسخه اصلاح شده:
def find_number_safe(numbers, target):
    i = 0
    while i < len(numbers):    # یک محدودیت دارد!
        if numbers[i] == target:
            return i
        i = i + 1
    return -1  # پیدا نشد، اما به درستی تمام شد
```

### بررسی سریع

از خود بپرسید: **"آیا این در نهایت برای همه ورودی‌های ممکن متوقف می‌شود؟"**

---

## ۲. ورودی: داده نیاز دارد (یا قبول می‌کند)

### معنی آن

یک الگوریتم باید واضحاً تعریف کند با چه داده‌ای کار می‌کند. می‌تواند داشته باشد:
- **صفر ورودی**: داده را از جای دیگری می‌گیرد (مثل ساعت سیستم)
- **یک یا چند ورودی**: داده خاصی برای پردازش قبول می‌کند

### تشبیه دنیای واقعی: دستگاه فروش

**با ورودی:**
```
الگوریتم: دستگاه فروش
ورودی: کد محصول (A1، B2، و غیره)، مبلغ پول
پردازش: بررسی قیمت، تحویل محصول، دادن باقی‌مانده
خروجی: محصول، باقی‌مانده
```

**بدون ورودی (صفر ورودی):**
```
الگوریتم: نمایش زمان فعلی
ورودی: (هیچ - از سیستم می‌خواند)
پردازش: خواندن ساعت سیستم
خروجی: نمایش زمان فعلی
```

### مثال‌های کد

**با چندین ورودی:**
```python
def calculate_tip(bill_amount, tip_percentage):
    """
    ورودی: 
      - bill_amount (عدد): صورت حساب کل
      - tip_percentage (عدد): درصد انعام (مثلاً ۱۵ برای ۱۵٪)
    خروجی: مبلغ انعام
    """
    return bill_amount * (tip_percentage / 100)

# استفاده:
tip = calculate_tip(50.00, 15)  # ورودی: ۵۰، ۱۵
print(f"Tip: ${tip}")           # خروجی: ۷٫۵
```

**با صفر ورودی:**
```python
import datetime

def get_current_day():
    """
    ورودی: هیچ (از سیستم می‌گیرد)
    خروجی: نام روز فعلی
    """
    return datetime.datetime.now().strftime("%A")

# استفاده:
day = get_current_day()  # نیازی به ورودی نیست!
print(f"Today is {day}")
```

**چرا صفر ورودی معتبر است:**
بعضی کارها نیازی به داده خارجی ندارند. گرفتن زمان فعلی، تولید عدد تصادفی، یا بررسی وضعیت سیستم همه الگوریتم‌های معتبر بدون ورودی هستند.

### اعتبارسنجی ورودی مهم است!

```python
def divide_numbers(a, b):
    """
    ورودی: دو عدد
    خروجی: a تقسیم بر b
    """
    if b == 0:
        return "Error: Cannot divide by zero"
    return a / b

# خوب: با ورودی نامعتبر به خوبی برخورد می‌کند
# همچنان ورودی‌های مشخص دارد، فقط آنها را اعتبارسنجی می‌کند
```

---

## ۳. قطعیت: هر گام باید کاملاً واضح باشد

### معنی آن

هر گام باید آنقدر دقیق باشد که هر کسی (یا هر کامپیوتری) بتواند بدون حدس زدن آن را دنبال کند.

### تشبیه دنیای واقعی: دنبال کردن مسیر

**دستورالعمل‌های مبهم (بد):**
```
نحوه رسیدن به پارک:
۱. کمی راه بروید
۲. جایی بپیچید
۳. تا جایی که می‌بینید بروید
```

**دستورالعمل‌های قطعی (خوب):**
```
نحوه رسیدن به پارک:
۱. از ساختمان خارج شوید، به چپ بپیچید در خیابان Main
۲. ۳ بلوک راه بروید (از ۲ چراغ راهنمایی عبور کنید)
۳. به راست بپیچید در خیابان Oak
۴. ۲ بلوک راه بروید
۵. ورودی پارک در سمت چپ شماست (دروازه آهنی بزرگ)
```

### مثال‌های کد

**نامشخص (بد):**
```python
def sort_list(items):
    # "آیتم‌ها را به نحوی مرتب کن"
    # روش مرتب‌سازی واضح نیست!
    pass

# چه الگوریتمی؟ حبابی؟ سریع؟
# صعودی یا نزولی؟
# در مورد تساوی چه؟
```

**قطعی (خوب):**
```python
def sort_list_ascending(items):
    """
    مرتب‌سازی آیتم‌ها به ترتیب صعودی با استفاده از مرتب‌سازی حبابی.
    """
    n = len(items)
    for i in range(n):
        for j in range(0, n - i - 1):
            if items[j] > items[j + 1]:
                # جابجایی اگر خارج از ترتیب باشند
                items[j], items[j + 1] = items[j + 1], items[j]
    return items

# واضح: از مرتب‌سازی حبابی، ترتیب صعودی استفاده می‌کند
```

### مثال‌های بیشتر

**دستور غذا: تهیه چای**

| مبهم | قطعی |
|-------|----------|
| "مقداری آب بجوشانید" | "۲ پیمانه آب را تا ۱۰۰°C گرم کنید" |
| "چای اضافه کنید" | "۱ کیسه چای اضافه کنید" |
| "کمی صبر کنید" | "۳ دقیقه دم بدهید" |
| "شکر اگر می‌خواهید" | "۱ قاشق چایخوری شکر (اختیاری)" |

### چرا این اهمیت دارد

کامپیوترها بسیار تحت‌اللفظی هستند. آنها نمی‌توانند:
- حدس بزنند منظور شما چیست
- فرضیات بسازند
- "بفهمند"

هر جزئیات باید مشخص شود!

---

## ۴. اثربخشی: هر گام باید قابل انجام باشد

### معنی آن

هر عملیات باید ساده‌تر از حدی باشد که بتوان دقیقاً، در زمان پایانی، با منابع موجود انجام داد.

### تشبیه دنیای واقعی: ساختن خانه پرنده

**گام‌های مؤثر (خوب):**
```
۱. چوب را به قطعات ۶ اینچی برش دهید (با اره ممکن است)
۲. لبه‌ها را سنباده بزنید (با سنباده ممکن است)
۳. قطعات را با میخ به هم وصل کنید (با چکش ممکن است)
۴. اگر می‌خواهید رنگ کنید (با قلم‌مو ممکن است)
```

**گام‌های غیرمؤثر (بد):**
```
۱. چوب را با لیزر برش دهید (برای انسان‌ها غیرممکن)
۲. آن را "خوب" کنید (خیلی مبهم)
۳. اطمینان حاصل کنید برای همیشه دوام می‌آورد (غیرممکن)
۴. پرندگان را عاشق آن کنید (نمی‌توان احساسات پرندگان را کنترل کرد)
```

### مثال‌های کد

**غیرمؤثر (بد):**
```python
def solve_world_hunger():
    # "پایان دادن به گرسنگی جهان" - نجیبانه، اما یک گام ملموس نیست!
    end_all_poverty()
    fix_all_economies()
    distribute_food_globally()
    # اینها گام‌های خاص و قابل اجرا نیستند
```

**مؤثر (خوب):**
```python
def calculate_average(numbers):
    """
    گام‌های مؤثر:
    ۱. جمع همه اعداد (جمع پایه است)
    ۲. شمارش تعداد (len() پایه است)
    ۳. تقسیم مجموع بر تعداد (تقسیم پایه است)
    """
    total = sum(numbers)      # عملیات پایه
    count = len(numbers)      # عملیات پایه
    return total / count      # عملیات پایه
```

### چه چیزی "مؤثر" محسوب می‌شود؟

یک عملیات مؤثر است اگر:
- ✓ می‌توان آن را دقیقاً انجام داد
- ✓ زمان پایانی می‌برد
- ✓ نتیجه قطعی تولید می‌کند
- ✓ توسط کامپیوتر/شخص قابل انجام است

**مثال‌های عملیات مؤثر:**
- حساب: `+`، `-`، `*`، `/`
- مقایسه: `<`، `>`، `==`
- انتساب: `x = 5`
- I/O پایه: خواندن ورودی، چاپ خروجی

---

## ۵. خروجی: باید نتیجه‌ای تولید کند

### معنی آن

یک الگوریتم باید حداقل یک خروجی یا نتیجه مشخص تولید کند. خروجی باید قابل دستیابی و مفید باشد.

### تشبیه دنیای واقعی: آزمون

**خروجی (خوب):**
```
آزمون دانشجو:
ورودی: پاسخ‌های دانشجو به سوالات
پردازش: نمره دادن به هر پاسخ
خروجی: نمره (۰-۱۰۰)، وضعیت قبول/مردود
```
نتیجه‌ای می‌گیرید که می‌توانید از آن استفاده کنید!

**بدون خروجی (بد):**
```
فرآیند مرموز:
ورودی: پاسخ‌های دانشجو
پردازش: (محاسبات داخلی انجام می‌شود)
خروجی: (هیچ چیز نشان داده نمی‌شود)
```
هدف چه بود؟ نمی‌توانیم نتیجه را ببینیم یا استفاده کنیم!

### مثال‌های کد

**خروجی واضح (خوب):**
```python
def find_maximum(numbers):
    """
    خروجی: بزرگ‌ترین عدد در لیست
    """
    max_val = numbers[0]
    for num in numbers:
        if num > max_val:
            max_val = num
    return max_val  # خروجی واضح و واحد

result = find_maximum([3, 7, 2, 9, 1])
print(f"Maximum: {result}")  # Maximum: 9
```

**بدون خروجی (بد):**
```python
def find_maximum_silent(numbers):
    max_val = numbers[0]
    for num in numbers:
        if num > max_val:
            max_val = num
    # گمشده: دستور return!
    # نتیجه وجود دارد اما برای همیشه از دست رفته است

result = find_maximum_silent([3, 7, 2, 9, 1])
print(f"Maximum: {result}")  # Maximum: None
```

### خروجی‌های چندگانه

بعضی الگوریتم‌ها چندین قطعه اطلاعات تولید می‌کنند:

```python
def analyze_number(n):
    """
    خروجی‌های چندگانه درباره یک عدد
    """
    is_even = (n % 2 == 0)
    is_positive = (n > 0)
    digit_count = len(str(abs(n)))
    
    return is_even, is_positive, digit_count
    # ۳ قطعه اطلاعات برمی‌گرداند

even, positive, digits = analyze_number(42)
print(f"42 is even: {even}, positive: {positive}, has {digits} digits")
# خروجی: 42 is even: True, positive: True, has 2 digits
```

---

## فراتر از پایه‌ها: ویژگی‌های کیفی

هنگامی که FIDEO را دارید، این موارد الگوریتم شما را *خوب* می‌کنند:

### ۱. درستی: واقعاً کار می‌کند!

```python
# ادعا می‌کند حداکثر را پیدا می‌کند
def broken_max(numbers):
    return numbers[0]  # فقط اولین آیتم را برمی‌گرداند!

# تست: [۵، ۲، ۸، ۱]
# انتظار: ۸
# واقعی: ۵
# ✗ نادرست!
```

### ۲. کارایی: منابع را هدر نمی‌دهد

```python
# ناکارآمد: حتی پس از یافتن پاسخ هر آیتم را بررسی می‌کند
def inefficient_search(items, target):
    found = False
    for item in items:
        if item == target:
            found = True
        # حتی پس از یافتن به بررسی ادامه می‌دهد!
    return found

# کارآمد: به محض یافتن متوقف می‌شود
def efficient_search(items, target):
    for item in items:
        if item == target:
            return True  # فوراً متوقف شو!
    return False
```

### ۳. استحکام: با موارد عجیب برخورد می‌کند

```python
# محکم نیست - روی لیست خالی crash می‌کند
def fragile_average(numbers):
    return sum(numbers) / len(numbers)

# محکم - موارد خاص را مدیریت می‌کند
def robust_average(numbers):
    if len(numbers) == 0:
        return 0  # یا خطای واضح raise کنید
    return sum(numbers) / len(numbers)
```

---

## تمرین: درک خود را بیازمایید

### تمرین ۱: آیا الگوریتم است؟

هر روال را با FIDEO بررسی کنید:

**روال A:**
```
۱. دریافت یک عدد از کاربر
۲. اگر عدد > ۰، چاپ "مثبت"
۳. اگر عدد < ۰، چاپ "منفی"
۴. در غیر این صورت چاپ "صفر"
```

**تحلیل:**
- F - پایان‌پذیر؟ ✓ (۳ گام)
- I - ورودی؟ ✓ (یک عدد)
- D - قطعی؟ ✓ (شرایط واضح)
- E - مؤثر؟ ✓ (مقایسه و چاپ پایه‌اند)
- O - خروجی؟ ✓ (نتیجه را چاپ می‌کند)

**رأی:** بله، یک الگوریتم است!

---

**روال B:**
```
۱. مقدار x = ۱ را تنظیم کنید
۲. در حالی که x > ۰:
   - چاپ x
   - x = x + ۱
```

**تحلیل:**
- F - پایان‌پذیر؟ ✗ (x برای همیشه رشد می‌کند، هرگز متوقف نمی‌شود!)
- I - ورودی؟ ✗ (بدون ورودی، اما اشکالی ندارد)
- D - قطعی؟ ✓
- E - مؤثر؟ ✓
- O - خروجی؟ ✓ (اما خروجی بی‌نهایت!)

**رأی:** خیر، پایان‌پذیری را رد می‌کند!

---

**روال C:**
```
۱. مواد را تا جایی که طعم خوبی داشته باشد اضافه کنید
۲. تا جایی که پخته شود بپزید
۳. سرو کنید
```

**تحلیل:**
- F - پایان‌پذیر؟ شاید؟ "تا پخته شود" مبهم است
- I - ورودی؟ "مواد" - چه موادی؟ چقدر؟
- D - قطعی؟ ✗ "طعم خوب" و "پخته" ذهنی هستند
- E - مؤثر؟ ✓ (پختن ممکن است)
- O - خروجی؟ ✓ (غذا)

**رأی:** خیر، قطعیت را رد می‌کند!

---

### تمرین ۲: رفع مشکلات

**مشکل ۱: پایان‌پذیر کردن**
```python
# فعلی: حلقه بی‌نهایت
def count_forever():
    n = 1
    while n > 0:      # همیشه درست است!
        print(n)
        n = n + 1     # هرگز متوقف نمی‌شود

# رفع: افزودن شرط توقف
def count_to_ten():
    n = 1
    while n <= 10:    # الآن محدودیت دارد!
        print(n)
        n = n + 1
    print("Done!")
```

**مشکل ۲: قطعی کردن**
```python
# فعلی: مبهم
def make_cookies():
    # "مواد را اضافه کنید"
    # "برای مدتی بپزید"
    pass

# رفع: دستورالعمل‌های مشخص
def make_cookies():
    ingredients = ["۲ پیمانه آرد", "۱ پیمانه شکر", "۲ تخم‌مرغ"]
    mix(ingredients)
    bake(temperature=350, minutes=12)
    return "Cookies ready!"
```

---

## مرجع سریع: چک لیست FIDEO

هنگام طراحی الگوریتم، از خود بپرسید:

```
┌─────────────────────────────────────────────────────────────┐
│                 چک لیست الگوریتم FIDEO                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ☑ پایان‌پذیر    آیا پس از تعداد مشخصی گام متوقف می‌شود؟   │
│                (حلقه‌های بی‌نهایت را بررسی کنید!)           │
│                                                             │
│  ☑ ورودی       چه داده‌ای نیاز دارد؟                       │
│                (صفر، یک یا چند - اما باید تعریف شود)        │
│                                                             │
│  ☑ قطعی       آیا هر دستور کاملاً واضح است؟                │
│                (حدس زدن مجاز نیست!)                        │
│                                                             │
│  ☑ مؤثر       آیا هر گام واقعاً قابل انجام است؟             │
│                (همه عملیات باید ملموس باشند)              │
│                                                             │
│  ☑ خروجی      آیا حداقل یک نتیجه واضح تولید می‌کند؟        │
│                (باید چیزی برگردانیم!)                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## به خاطر بسپارید!

### ۵ ویژگی به زبان ساده

| حرف | ویژگی | تعریف ساده | سوال آزمون |
|--------|----------------|-------------------|---------------|
| **F** | پایان‌پذیری | باید تمام شود | "در نهایت متوقف می‌شود؟" |
| **I** | ورودی | داده قبول می‌کند | "چه اطلاعاتی نیاز دارد؟" |
| **D** | قطعیت | کاملاً واضح | "آیا کامپیوتر می‌تواند دقیقاً این را دنبال کند؟" |
| **E** | مؤثر | واقعاً قابل انجام | "آیا هر گام ممکن است؟" |
| **O** | خروجی | نتیجه تولید می‌کند | "در انتها چه چیزی می‌گیریم؟" |

---

## نکات کلیدی

1. **FIDEO تعریف می‌کند چه چیزی الگوریتم است** - نه فقط هر مجموعه‌ای از گام‌ها
2. **پایان‌پذیری حیاتی است** - حلقه‌های بی‌نهایت الگوریتم نیستند
3. **قطعیت از باگ‌ها جلوگیری می‌کند** - گام‌های مبهم به نتایج نادرست منجر می‌شوند
4. **مؤثر بودن آن را عملی نگه می‌دارد** - هر گام باید ممکن باشد
5. **ورودی و خروجی رابط را تعریف می‌کنند** - الگوریتم چگونه با دنیا صحبت می‌کند

### گام‌های بعدی

- تمرین نوشتن الگوریتم‌هایی که هر ۵ ویژگی را برآورده می‌کنند
- تحلیل روال‌های روزمره با استفاده از FIDEO
- یادگیری درباره کارایی و تحلیل پیچیدگی
- مطالعه الگوریتم‌های واقعی و تأیید اینکه همه معیارها را دارند
