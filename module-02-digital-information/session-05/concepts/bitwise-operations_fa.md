# عملیات بیتی: قدرت کار با بیت‌های فردی

## مقدمه: مثل کامپیوتر فکر کردن

تصور کنید ۸ کلید روشنایی دارید، هر کدام برچسب ۰ تا ۷. به جای اینکه همه را یکسان در نظر بگیرید، می‌خواهید:
- فقط کلید شماره ۳ را روشن کنید
- بررسی کنید آیا کلید شماره ۵ روشن است
- وضعیت همه کلیدها را برعکس کنید

این دقیقاً کاری است که **عملیات بیتی** انجام می‌دهند! به شما اجازه می‌دهند بیت‌های فردی - کوچکترین قطعات داده در کامپیوتر - را دستکاری کنید.

---

## چرا عملیات بیتی را یاد بگیریم؟

### کاربردهای دنیای واقعی

| مورد استفاده | عملیات بیتی چگونه کمک می‌کند |
|--------------|------------------------------|
| **گرافیک** | تغییر رنگ‌ها، اعمال فیلترها |
| **توسعه بازی** | ذخیره چندین پرچم (آیا بازیکن در حال پرش است؟ تیراندازی؟ شکست‌ناپذیر؟) |
| **شبکه‌سازی** | بررسی آدرس‌های IP، شماره پورت‌ها |
| **مجوزهای فایل** | تنظیم مجوزهای خواندن/نوشتن/اجرا |
| **فشرده‌سازی** | بسته‌بندی کارآمد داده |
| **رمزنگاری** | مخلوط کردن داده برای امنیت |
| **عملکرد** | سریع‌تر از حساب معمولی |

### تشبیه: ردیف کلیدهای روشنایی

یک عدد ۸ بیتی را به عنوان ۸ کلید روشنایی تصور کنید:
```
موقعیت بیت:  ۷   ۶   ۵   ۴   ۳   ۲   ۱   ۰
کلید:       [ ] [ ] [ ] [ ] [X] [ ] [ ] [ ]
دودویی:      ۰   ۰   ۰   ۰   ۱   ۰   ۰   ۰   = ۸

فقط کلید شماره ۳ (موقعیت ۳) روشن است
```

---

## شش عملیات بیتی پایه

### ۱. AND (&): هر دو باید روشن باشند

**قاعده:** نتیجه ۱ است فقط اگر **هر دو** بیت ۱ باشند.

| A | B | A & B |
|---|---|-------|
| ۰ | ۰ | ۰ |
| ۰ | ۱ | ۰ |
| ۱ | ۰ | ۰ |
| ۱ | ۱ | ۱ |

**مثل این فکر کنید:** دو نفر باید هر دو چیزی را تأیید کنند.

**مثال:**
```
  11001100    (۲۰۴)
& 10101010    (۱۷۰)
----------
  10001000    (۱۳۶)
  
فقط موقعیت‌هایی که هر دو ۱ دارند ۱ باقی می‌مانند
```

**کاربرد عملی:** ماسک‌بندی (پنهان کردن بیت‌هایی که اهمیتی ندارند)

---

### ۲. OR (|): حداقل یکی روشن است

**قاعده:** نتیجه ۱ است اگر **حداقل یک** بیت ۱ باشد.

| A | B | A \| B |
|---|---|-------|
| ۰ | ۰ | ۰ |
| ۰ | ۱ | ۱ |
| ۱ | ۰ | ۱ |
| ۱ | ۱ | ۱ |

**مثل این فکر کنید:** هر شخص می‌تواند تأیید کند.

**مثال:**
```
  11001100    (۲۰۴)
| 10101010    (۱۷۰)
----------
  11101110    (۲۳۸)
  
هر موقعیت با حداقل یک ۱، ۱ باقی می‌ماند
```

**کاربرد عملی:** تنظیم پرچم‌ها (روشن کردن بیت‌ها)

---

### ۳. XOR (^): بیت‌های متفاوت

**قاعده:** نتیجه ۱ است اگر بیت‌ها **متفاوت** باشند.

| A | B | A ^ B |
|---|---|-------|
| ۰ | ۰ | ۰ |
| ۰ | ۱ | ۱ |
| ۱ | ۰ | ۱ |
| ۱ | ۱ | ۰ |

**مثل این فکر کنید:** "آیا اینها متفاوت هستند؟"

**مثال:**
```
  11001100    (۲۰۴)
^ 10101010    (۱۷۰)
----------
  01100110    (۱۰۲)
  
موقعیت‌هایی که بیت‌ها متفاوت هستند ۱ می‌شوند
```

**کاربرد عملی:**
- تغییر وضعیت بیت‌ها (روشن به خاموش، خاموش به روشن)
- رمزنگاری ساده (XOR با یک کلید)
- یافتن تفاوت بین دو مقدار

---

### ۴. NOT (~): معکوس کردن همه بیت‌ها

**قاعده:** هر ۰ را به ۱ و هر ۱ را به ۰ تبدیل کنید.

| A | ~A |
|---|----|
| ۰ | ۱ |
| ۱ | ۰ |

**مثال:**
```
~ 00001111    (۱۵)
----------
  11110000    (۲۴۰ در ۸ بیتی بدون علامت)
  
همه بیت‌ها معکوس شدند
```

**نکته:** در برنامه‌نویسی، نتیجه به تعداد بیت‌های عدد شما (۸ بیت، ۱۶ بیت، ۳۲ بیت و غیره) بستگی دارد.

---

### ۵. شیفت چپ (<<): جابجایی بیت‌ها به چپ

**قاعده:** همه بیت‌ها را به چپ جابجا کنید، راست را با ۰ پر کنید.

**اثر:** هر شیفت چپ در ۲ ضرب می‌کند!

**مثال:**
```
00000101 (۵)
<< ۱
--------
00001010 (۱۰)  = ۵ × ۲

00000101 (۵)
<< ۲
--------
00010100 (۲۰)  = ۵ × ۴

00000101 (۵)
<< ۳
--------
00101000 (۴۰)  = ۵ × ۸
```

**کاربرد عملی:**
- ضرب سریع بر توان‌های ۲
- تنظیم ماسک‌های بیت
- ایجاد پرچم‌ها

---

### ۶. شیفت راست (>>): جابجایی بیت‌ها به راست

**قاعده:** همه بیت‌ها را به راست جابجا کنید، چپ را با ۰ (یا بیت علامت برای اعداد علامت‌دار) پر کنید.

**اثر:** هر شیفت راست بر ۲ تقسیم می‌کند!

**مثال (بدون علامت):**
```
00010100 (۲۰)
>> ۱
--------
00001010 (۱۰)  = ۲۰ ÷ ۲

00010100 (۲۰)
>> ۲
--------
00000101 (۵)   = ۲۰ ÷ ۴
```

**کاربرد عملی:**
- تقسیم سریع بر توان‌های ۲
- استخراج بیت‌های خاص
- باز کردن بسته‌بندی داده فشرده

---

## کاربردهای عملی

### کاربرد ۱: بررسی زوج یا فرد بودن عدد

**ترفند:** به بیت راست‌ترین نگاه کنید (بیت ۰)
- ۰ = زوج
- ۱ = فرد

```python
# بررسی زوج بودن عدد
def is_even(number):
    return (number & 1) == 0

# بررسی فرد بودن عدد  
def is_odd(number):
    return (number & 1) == 1

# مثال‌ها:
is_even(4)   # ۴ & ۱ = ۰، True برمی‌گرداند ✓
is_even(7)   # ۷ & ۱ = ۱، False برمی‌گرداند ✓
is_odd(7)    # ۷ & ۱ = ۱، True برمی‌گرداند ✓
```

**نحوه کار:**
```
۴ = 100
۱ = 001
& = 000 = ۰ → زوج!

۷ = 111
۱ = 001
& = 001 = ۱ → فرد!
```

---

### کاربرد ۲: تنظیم یک بیت خاص

**هدف:** روشن کردن یک بیت خاص (موقعیت n)

```python
def set_bit(number, position):
    return number | (1 << position)

# مثال‌ها:
set_bit(0b0000, 2)   # بیت ۲ را تنظیم کنید
# ۱ << ۲ = 0b0100
# 0b0000 | 0b0100 = 0b0100 = ۴

set_bit(0b1000, 0)   # بیت ۰ را تنظیم کنید
# ۱ << ۰ = 0b0001
# 0b1000 | 0b0001 = 0b1001 = ۹
```

---

### کاربرد ۳: پاک کردن یک بیت خاص

**هدف:** خاموش کردن یک بیت خاص (موقعیت n)

```python
def clear_bit(number, position):
    return number & ~(1 << position)

# مثال‌ها:
clear_bit(0b1111, 2)  # بیت ۲ را پاک کنید
# ۱ << ۲ = 0b0100
# ~0b0100 = 0b1011 (در ۴ بیت)
# 0b1111 & 0b1011 = 0b1011 = ۱۱
```

---

### کاربرد ۴: تغییر وضعیت یک بیت

**هدف:** برعکس کردن یک بیت (روشن→خاموش یا خاموش→روشن)

```python
def toggle_bit(number, position):
    return number ^ (1 << position)

# مثال‌ها:
toggle_bit(0b1010, 0)  # بیت ۰ را تغییر دهید
# 0b1010 ^ 0b0001 = 0b1011 = ۱۱
# قبلاً ۰ بود، حالا ۱

toggle_bit(0b1011, 0)  # بیت ۰ را دوباره تغییر دهید
# 0b1011 ^ 0b0001 = 0b1010 = ۱۰
# قبلاً ۱ بود، حالا ۰
```

---

### کاربرد ۵: بررسی تنظیم بودن یک بیت

**هدف:** آیا یک بیت خاص روشن است؟

```python
def is_bit_set(number, position):
    return (number & (1 << position)) != 0

# مثال‌ها:
is_bit_set(0b1010, 1)  # بیت ۱ را بررسی کنید
# 0b1010 & 0b0010 = 0b0010 != ۰ → True

is_bit_set(0b1010, 0)  # بیت ۰ را بررسی کنید
# 0b1010 & 0b0001 = 0b0000 == ۰ → False
```

---

### کاربرد ۶: مجوزهای فایل (سبک یونیکس)

در سیستم‌های یونیکس/لینوکس، مجوزهای فایل از ۳ بیت برای هر یک از ۳ گروه استفاده می‌کنند:

```
فرمت مجوز: rwx rwx rwx
                    │   │   │
                 مالک گروه سایرین

r = خواندن    (۴) = 100
w = نوشتن   (۲) = 010
x = اجرا    (۱) = ۰۰۱
```

**مقادیر مجوز رایج:**
```
۷ = ۱۱۱ = rwx (خواندن، نوشتن، اجرا)
۶ = ۱۱۰ = rw- (خواندن، نوشتن، بدون اجرا)
۵ = ۱۰۱ = r-x (خواندن، بدون نوشتن، اجرا)
۴ = ۱۰۰ = r-- (فقط خواندن)
۰ = ۰۰۰ = --- (بدون مجوز)

مجوز ۷۵۵ = rwxr-xr-x
  مالک:  ۷ = ۱۱۱ = rwx
  گروه:  ۵ = ۱۰۱ = r-x
  سایرین: ۵ = ۱۰۱ = r-x
```

**بررسی مجوزها با بیتی:**
```python
def can_read(permissions):
    return (permissions & 4) != 0  # بیت خواندن را بررسی کنید

def can_write(permissions):
    return (permissions & 2) != 0  # بیت نوشتن را بررسی کنید

def can_execute(permissions):
    return (permissions & 1) != 0  # بیت اجرا را بررسی کنید

# مثال: بررسی اینکه آیا مالک می‌تواند بنویسد
owner_perms = 7  # rwx
if can_write(owner_perms):
    print("می‌تواند بنویسد!")
```

---

### کاربرد ۷: ذخیره چندین پرچم بولی

به جای استفاده از چندین متغیر بولی، آنها را در یک عدد صحیح بسته‌بندی کنید:

```python
# تعریف پرچم‌ها
IS_VISIBLE = 1 << 0    # بیت ۰
IS_ENABLED = 1 << 1    # بیت ۱  
IS_HOVERED = 1 << 2    # بیت ۲
IS_CLICKED = 1 << 3    # بیت ۳

# تنظیم چندین پرچم
button_state = IS_VISIBLE | IS_ENABLED
# 0001 | 0010 = 0011

# بررسی تنظیم بودن پرچم خاص
if button_state & IS_VISIBLE:
    print("دکمه قابل مشاهده است")

# افزودن یک پرچم
button_state |= IS_HOVERED
# 0011 | 0100 = 0111

# حذف یک پرچم
button_state &= ~IS_ENABLED
# 0111 & 1101 = 0101
```

**صرفه‌جویی در حافظه:**
- ۴ بولی جداگانه: ۴ بایت (معمولاً)
- ۱ عدد صحیح با ۴ پرچم: ۴ بایت
- اما می‌توانید ۳۲ پرچم را در یک عدد صحیح ۳۲ بیتی بسته‌بندی کنید!

---

## ماسک‌های بیت رایج

### ماسک چیست؟

یک **ماسک** یک الگوی بیت است برای انتخاب یا تغییر بیت‌های خاص.

### ماسک‌های رایج

| هدف | ماسک (۸ بیتی) | توضیحات |
|-----|---------------|---------|
| ۴ بیت پایین‌تر | 00001111 | فقط بیت‌های ۰-۳ را نگه دارید |
| ۴ بیت بالاتر | 11110000 | فقط بیت‌های ۴-۷ را نگه دارید |
| بیت‌های زوج | 01010101 | بیت‌های ۰، ۲، ۴، ۶ را نگه دارید |
| بیت‌های فرد | 10101010 | بیت‌های ۱، ۳، ۵، ۷ را نگه دارید |
| یک بیت | 00001000 | فقط بیت ۳ را نگه دارید |

### استفاده از ماسک‌ها

```python
# استخراج ۴ بیت پایین‌تر
value = 0b10110101
lower_4 = value & 0b00001111
# نتیجه: 0b00000101 = ۵

# استخراج ۴ بیت بالاتر
upper_4 = (value & 0b11110000) >> 4
# نتیجه: 0b00001011 = ۱۱
```

---

## تمرین‌های عملی

### تمرین ۱: AND، OR، XOR
اینها را با دست محاسبه کنید:

۱. 1100 & 1010 = _______
۲. 1100 | 1010 = _______
۳. 1100 ^ 1010 = _______
۴. ~1100 (۴ بیتی) = _______

### تمرین ۲: شیفت‌ها
محاسبه کنید:

۱. 00001011 << ۲ = _______
۲. 00001011 >> ۲ = _______
۳. 00110000 >> ۴ = _______

### تمرین ۳: دستکاری بیت
برای number = 0b10101100:

۱. بیت ۱ را تنظیم کنید: _______
۲. بیت ۶ را پاک کنید: _______
۳. بیت ۳ را تغییر دهید: _______
۴. بررسی کنید آیا بیت ۴ تنظیم شده: _______

### تمرین ۴: سناریوی دنیای واقعی

**استخراج رنگ:**
رنگ یک پیکسل به صورت 0xFF5733 (نارنجی) ذخیره شده. این فرمت RGB است:
- قرمز: FF (بیت‌های ۱۶-۲۳)
- سبز: ۵۷ (بیت‌های ۸-۱۵)
- آبی: ۳۳ (بیت‌های ۰-۷)

با استفاده از شیفت‌های بیت و ماسک‌ها، هر جزء رنگ را استخراج کنید.

---

## نکات کلیدی

۱. **AND (&)** بیت‌هایی را که هر دو ۱ هستند نگه می‌دارد - برای ماسک‌بندی استفاده می‌شود
۲. **OR (|)** بیت‌هایی را که حداقل یکی ۱ است نگه می‌دارد - برای تنظیم استفاده می‌شود
۳. **XOR (^)** بیت‌هایی را که متفاوت هستند نگه می‌دارد - برای تغییر وضعیت استفاده می‌شود
۴. **NOT (~)** همه بیت‌ها را معکوس می‌کند - برای معکوس کردن استفاده می‌شود
۵. **شیفت‌ها (<<، >>)** بیت‌ها را چپ/راست جابجا می‌کنند - برای ضرب/تقسیم بر ۲ استفاده می‌شود
۶. **بیتی سریع است** - عملیات در سطح سخت‌افزار اتفاق می‌افتد

## به یاد داشته باشید

| عملیات | نماد | وقتی می‌خواهید... |
|--------|------|-------------------|
| AND | & | بررسی کنید آیا بیت‌ها هر دو تنظیم شده‌اند، بیت‌ها را ماسک کنید |
| OR | \| | بیت‌ها را ۱ کنید |
| XOR | ^ | بیت‌ها را تغییر دهید، تفاوت‌ها را پیدا کنید |
| NOT | ~ | همه بیت‌ها را معکوس کنید |
| شیفت چپ | << | در ۲ ضرب کنید، بیت‌ها را چپ جابجا کنید |
| شیفت راست | >> | بر ۲ تقسیم کنید، بیت‌ها را راست جابجا کنید |

---

## گام‌های بعدی

- تمرین مسائل دستکاری بیت
- یادگیری درباره پرچم‌ها و ماسک‌ها در کد واقعی
- بررسی عملیات بیتی در زبان برنامه‌نویسی خود
- مطالعه نحوه استفاده گرافیک از بیتی برای دستکاری رنگ
